#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\begin_preamble

\end_preamble
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 1 0 35 -1
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
El problema del viajante de comercio
\newline
Inteligencia Artificial
\end_layout

\begin_layout Author
Vicente J.
 Ferrer Dalmau (43152879A)
\newline
<vicente@jdalmau.es>
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Enunciado
\end_layout

\begin_layout Standard
Un señor viajante de comercio debe visitar n ciudades en su trabajo diario
 
\begin_inset Formula $c_{1},c_{2},...c_{n}$
\end_inset

 de manera que una de ellas, la ciudad 
\begin_inset Formula $c_{i}$
\end_inset

, constituye el punto de partida y llegada del camino a seguir en la visita.
 Se considera que existen rutas directas entre cada par de ciudades del
 conjunto considerado, de manera que cada ruta tiene un costo específico
 asociado.
 El problema consiste en determinar, partiendo y llegando a una misma ciudad
 
\begin_inset Formula $c_{i}$
\end_inset

, una ruta óptima que permita visitar las n ciudades consideradas en un
 tiempo mínimo.
 El mencionado problema debe resolverse aplicando cada una de las siguientes
 técnicas:
\newline

\newline
TÉCNICAS DE BÚSQUEDA NO INFORMADA
\end_layout

\begin_layout Itemize
Primero en profundidad.
\end_layout

\begin_layout Itemize
Primero en profundidad con ramificación y poda.
\end_layout

\begin_layout Itemize
Búsqueda de costo uniforme.
\end_layout

\begin_layout Standard
TÉCNICAS DE BÚSQUEDA INFORMADA
\end_layout

\begin_layout Itemize
El vecino más próximo.
\end_layout

\begin_layout Itemize
Método de escalada.
\end_layout

\begin_layout Itemize
Búsqueda A*, en la que debe diseñarse –como mínimo- una heurística haciendo
 uso de la técnica del problema relajado, para calcular la función h’.
\end_layout

\begin_layout Standard
Debe hacerse un análisis de cada una de las técnicas empleadas, determinando
 los casos en que cada técnica funciona mejor/peor; asimismo, deben compararse
 las diferentes técnicas, concluyendo sobre las ventajas de cada una respecto
 a las demás.
 
\end_layout

\begin_layout Standard
Respecto a la búsqueda A*, debe diseñarse al menos una heurística para el
 cálculo de h’, utilizando para ello la técnica del problema relajado.
 
\end_layout

\begin_layout Standard
Se valorará la capacidad de iniciativa de los estudiantes además de la presentac
ión de los resultados y la calidad del análisis de cada técnica.
\end_layout

\begin_layout Section
Búsqueda primero en profundidad
\end_layout

\begin_layout Standard
El algoritmo Primero en Profundidad es un algoritmo que nos permite realizar
 búsquedas en un árbol o grafo.
 Formalmente es una búsqueda no informada que progresa expandiendo el primer
 nodo hijo en el árbol de búsqueda y continua hasta encontrar un nodo objetivo
 o hasta encontrar un nodo sin hijos.
 En ese momento, la búsqueda realiza una vuelta atrás (backtracking) volviendo
 al nodo más reciente que no había sido explorado completamente, para elegir
 el siguiente de sus hijos.
\end_layout

\begin_layout Subsubsection*

\bar under
Características del algoritmo
\end_layout

\begin_layout Standard
Aspectos positivos:
\end_layout

\begin_layout Itemize
La 
\series bold
memoria
\series default
 necesaria es relativamente pequeña, ya que en cada momento sólo hay que
 guardar la ruta que se está analizando.
\end_layout

\begin_layout Itemize
Si hay muchas soluciones posibles, la búsqueda en profundidad es 
\series bold
rápida
\series default
 ya que tiene muchas posibilidades de encontrar una solución después de
 haber explorado únicamente una parte del árbol.
 En nuestro caso esta ventaja no se da porque tenemos que recorrer todo
 el árbol para dar la mejor solución.
\end_layout

\begin_layout Standard
Aspectos negativos:
\end_layout

\begin_layout Itemize
Tiene un coste temporal 
\series bold
exponencial
\series default
, lo que para problemas grandes lo hace poco recomendable (en nuestro caso
 un número elevado de ciudades).
\end_layout

\begin_layout Itemize
En algunos casos el recorrido de ciertas rutas puede conllevar problemas,
 por ejemplo si tenemos rutas cíclicas o infinitas quedaríamos 
\series bold
estancados
\series default
, o bien podríamos encontrar soluciones no óptimas después de grandes recorridos
, o incluso llegar a una solución óptima pero después de haber analizado
 muchas rutas incorrectas.
 En definitiva y continuando con la conclusión de la primera desventaja,
 si la estructura sobre la que realiza la búsqueda es muy grande o infinita
 no es recomendable usar este algoritmo.
 
\end_layout

\begin_layout Subsubsection*

\bar under
Evaluación del algoritmo de búsqueda
\end_layout

\begin_layout Description
Completitud: No, ya que puede quedarse atrapado al descender por el camino
 equivocado en árboles de búsqueda muy profundos o incluso infinitos.
 En esos casos se encuentra con un bucle infinito y no devuelve nunca una
 solución.
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
temporal: 
\begin_inset Formula $b^{m}$
\end_inset

, lo que supone un coste inaceptable
\begin_inset Foot
status collapsed

\begin_layout Standard
Dónde 
\series bold
b
\series default
 es el factor de ramificación, en nuestro caso las ciudades aplicables,
 
\series bold
d
\series default
 es la profundidad de la solución y 
\series bold
m
\series default
 es la máxima profundidad del árbol de búsqueda.
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
espacial: 
\begin_inset Formula $bm$
\end_inset

, sólo necesita almacenar una rama del árbol de búsqueda.
\end_layout

\begin_layout Subsubsection*

\bar under
Resultados
\end_layout

\begin_layout Standard
A continuación se muestra la evolución temporal del algoritmo en función
 del número de ciudades del problema.
 Para cada una de las ejecuciones se atenderá al número de nodos que han
 sido expandidos durante la búsqueda (en el caso de este algoritmo siempre
 se expande el árbol completo):
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename alg01.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
El valor se dispara entre 10 y 11 ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Número de ciudades
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
22
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
89
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2677
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
18740
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
149921
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1349290
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13492901
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Valores obtenidos en la ejecución.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el gráfico puede observarse el claro comportamiento 
\series bold
exponencial
\series default
 del algoritmo.
 Cabe mencionar que sólo fue posible ejecutarlo con 
\series bold
11 ciudades
\series default
 cómo máximo.
\end_layout

\begin_layout Section
Búsqueda primero en profundidad con ramificación y poda
\end_layout

\begin_layout Standard
El algoritmo primero en profundidad con Ramificación y poda es una variante
 del algoritmo visto en el apartado anterior mejorado sustancialmente.
 El término (del inglés, Branch and Bound) se aplica mayoritariamente para
 resolver cuestiones o problemas de optimización.
\end_layout

\begin_layout Standard
La característica de esta técnica con respecto a la anterior es que el algoritmo
 se encarga de detectar en qué ramificación las soluciones dadas ya no están
 siendo óptimas (es decir, mejoran alguna obtenida préviamente), para «podar»
 esa rama del árbol y no continuar malgastando recursos y procesos en casos
 que se alejan de la solución óptima.
\end_layout

\begin_layout Subsubsection*

\bar under
Características del algoritmo
\end_layout

\begin_layout Standard
Aspectos positivos:
\end_layout

\begin_layout Itemize
Bajo consumo de memoria.
\end_layout

\begin_layout Itemize
Rápido si existen muchas soluciones.
\end_layout

\begin_layout Itemize
Permite su aplicación para un mayor número de ciudades que en el caso anterior.
\end_layout

\begin_layout Standard
Aspectos negativos:
\end_layout

\begin_layout Itemize
Coste temporal todavía exponencial.
\end_layout

\begin_layout Subsubsection*

\bar under
Evaluación del algoritmo de búsqueda
\end_layout

\begin_layout Description
Completitud: No, ya que, de nuevo, puede quedarse atrapado al descender
 por el camino equivocado en árboles de búsqueda muy profundos o incluso
 infinitos.
 En esos casos se encuentra con un bucle infinito y no devuelve nunca una
 solución.
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
temporal: exponencial.
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
espacial: lineal.
\end_layout

\begin_layout Subsubsection*

\bar under
Resultados
\end_layout

\begin_layout Standard
En este apartado se muestra la evolución temporal del algoritmo en función
 del número de ciudades del problema.
 Para cada una de las ejecuciones se atenderá al número de nodos que han
 sido expandidos durante la búsqueda.
 Hay que decir que para un número de ciudades constante, al variar los valores
 de su matriz de distancias, el número de nodos expandidos variará, es decir,
 el porcentaje del árbol de búsqueda que se visita varía.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename alg02.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Número de nodos expandidos en función del número de ciudades.
\newline
Aquí el valor
 se dispara con unas cuantas ciudades más que
\newline
en el caso anterior.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Número de ciudades
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
18
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
81
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
259
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
708
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2253
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8345
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16149
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
246241
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
319918
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1689825
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Valores obtenidos en la ejecución.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
De nuevo en la gráfica observamos el comportamiento 
\series bold
exponencial 
\series default
del algoritmo, aunque aquí el crecimiento importante se produce para un
 valor más elevado de ciudades.
 Este algoritmo permite ejecutarse con un valor máximo de 
\series bold
14 ciudades
\series default
.
\end_layout

\begin_layout Section
Búsqueda de costo uniforme
\end_layout

\begin_layout Standard
Mediante este algoritmo la búsqueda se realiza expandiendo todos los nodos
 hijo de un nodo padre y seleccionando aquel cuyo coste sea menor.
 Se procede de esta forma hasta que se encuentra la mejor solución.
 Observemos que si todos los nodos tienen el mismo coste tenemos un recorrido
 en anchura.
\end_layout

\begin_layout Standard
La búsqueda de coste uniforme encontrará la mejor solución si se cumple
 que el coste del camino nunca decrece a medida que avanzamos, requisito
 que se cumple para el problema del viajante de comercio.
 Para otro tipo de problemas dónde si pudiera producirse nunca sabríamos
 cuándo podríamos encontrar un coste negativo.
 El resultado provocaría la necesidad de realizar una búsqueda exhaustiva
 en todo el árbol.
\end_layout

\begin_layout Standard
Este algoritmo puede implementarse fácilmente con la ayuda de una estructura
 de datos 
\series bold
cola ordenada por prioridad
\series default
, dónde aquellos nodos con menor coste (del nodo inicial hasta dicho nodo)
 son más prioritarios.
\end_layout

\begin_layout Subsubsection*

\bar under
Características del algoritmo
\end_layout

\begin_layout Standard
Aspectos positivos:
\end_layout

\begin_layout Itemize
Es un algoritmo de búsqueda completo, si existe una solución siempre la
 encuentra.
\end_layout

\begin_layout Itemize
Es un algoritmo de búsqueda óptimo, siempre encuentra la mejor solución.
 
\end_layout

\begin_layout Standard
Aspectos negativos:
\end_layout

\begin_layout Itemize
La complejidad temporal sigue siendo elevada.
\end_layout

\begin_layout Itemize
Los requerimientos de espacio son elevados en tanto que hay que guardar
 los nodos de cada nivel, ya que constituyen posibles soluciones.
 
\end_layout

\begin_layout Subsubsection*

\bar under
Evaluación del algoritmo de búsqueda
\end_layout

\begin_layout Description
Completitud: Sí.
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
temporal: 
\begin_inset Formula $b^{d}$
\end_inset

 dónde d representa la profundidad de la solución.
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
espacial: 
\begin_inset Formula $b^{d}$
\end_inset

.
\end_layout

\begin_layout Subsubsection*

\bar under
Resultados
\end_layout

\begin_layout Standard
En este apartado se muestra la evolución temporal del algoritmo en función
 del número de ciudades del problema.
 Para cada una de las ejecuciones se atenderá al número de nodos que han
 sido expandidos durante la búsqueda.
 Hay que decir que para un número de ciudades constante, al variar los valores
 de su matriz de distancias, el número de nodos expandidos variará, es decir,
 el porcentaje del árbol de búsqueda que se visita varía.
 Además al mantenerse una cola de prioridad para los nodos abiertos es frecuente
 ver cómo el programa se queda sin memoria, para algunas configuraciones
 de esa misma matriz de distancias, y no puede completar la búsqueda; tal
 efecto se pone de manifiesto a partir de 
\series bold
12 ciudades
\series default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename alg03.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Número de nodos expandidos en función del número de ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Número de ciudades
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
42
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
136
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
641
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1703
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
29221
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13595
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
67942
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
106030
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
347424
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Valores obtenidos en la ejecución.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
De nuevo en la gráfica observamos el comportamiento 
\series bold
exponencial 
\series default
del algoritmo, aunque aquí hay que tener muy en cuenta el tema de 
\series bold
memoria
\series default
 (cola de prioridad para los nodos abiertos) cómo ya se mencionó anteriormente.
 Además atendiendo al tiempo de ejecución, pese a visitar menos nodos resulta
 por término general más
\series bold
 lento
\series default
 que el anterior algoritmo (Ramificación y Poda) debido de nuevo a la necesidad
 de gestionar la cola de prioridad.
 Este algoritmo permite ejecutarse con un valor máximo de 
\series bold
14 ciudades
\series default
.
\end_layout

\begin_layout Section
Búsqueda A estrella
\end_layout

\begin_layout Standard
El algoritmo A estrella es un algoritmo de búsqueda para grafos que encuentra
 el camino de menor coste entre un nodo inicial y un nodo meta.
\end_layout

\begin_layout Standard
Usa una función heurística (denotada f'(x), es una aproximación a f(x),
 función que proporciona la verdadera evaluación de un nodo) para determinar
 el orden en que la búsqueda visita nodos en el árbol.
 La mencionada función es la suma de otras dos funciones: una función que
 indica el coste del camino seguido hasta un cierto nodo (denotada g(x))
 y una estimación admisible de la distancia hasta la meta (h'(x)).
 La función de evaluación resulta entonces 
\begin_inset Formula $f'(x)=g(x)+h'(x)$
\end_inset

.
\end_layout

\begin_layout Standard
Empezando en un nodo inicial dado, el algoritmo expande el nodo con el menor
 valor de f'(x).
 A estrella mantiene un conjunto de soluciones parciales almacenadas en
 una 
\series bold
cola de prioridad
\series default
, cómo en el algoritmo del apartado anterior.
 La prioridad asignada a un camino x viene determinada por la función f'(x).
 El proceso continua hasta que una meta tiene un valor f'(x) menor que cualquier
 otro nodo en la cola (o hasta que el árbol ha sido completamente recorrido).
\end_layout

\begin_layout Subsubsection*

\bar under
Características del algoritmo
\end_layout

\begin_layout Standard
Aspectos positivos:
\end_layout

\begin_layout Itemize
Ningún otro algoritmo óptimo garantiza expandir menos nodos que A estrella.
\end_layout

\begin_layout Standard
Aspectos negativos:
\end_layout

\begin_layout Itemize
Alto consumo de memoria.
\end_layout

\begin_layout Subsubsection*

\bar under
Evaluación del algoritmo de búsqueda
\end_layout

\begin_layout Description
Completitud: Sí.
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
temporal: exponencial (debido a la heurística utilizada).
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
espacial: exponencial.
\end_layout

\begin_layout Subsubsection*

\bar under
Resultados
\end_layout

\begin_layout Standard
En cuanto a la 
\series bold
función heurística
\series default
 que se ha utilizado para resolver este problema, para obtener el valor
 de la estimación 
\series bold
h'(x)
\series default
 dado un nodo consideramos la profundidad a la que se encuentra dentro del
 árbol de búsqueda.
 Cuanto más cercano esté al número de ciudades del problema (por tanto a
 una solución) mejor valoración tendrá.
 Para calcular dicho valor consideraremos además de la profundidad del nodo
 una estimación del coste del camino entre dos ciudades cualquiera:
\end_layout

\begin_layout Standard
Si por ejemplo, los costes de las rutas entre las ciudades del problema
 pertenecen a una distribución uniforme U(100) y tomamos un coste aproximado
 de 15 unidades cómo coste entre dos ciudades cualquiera, tendremos:
\end_layout

\begin_layout Standard
\begin_inset Formula $h'(x)=(n-l(x))*15$
\end_inset


\end_layout

\begin_layout Standard
dónde
\series bold
:
\end_layout

\begin_layout Standard

\series bold
n 
\series default
representa el número de ciudades del problema.
\end_layout

\begin_layout Standard

\series bold
l(x)
\series default
 es la profundidad del nodo x.
\end_layout

\begin_layout Standard
En el caso considerado el valor h'(x) puede sobreestimar al valor real del
 coste de la ruta entre el nodo considerado y un nodo meta, ya que al tener
 valores de una U(100) óbviamente tendremos rutas con costes mayores a 15
 (constante considerada).
 Lo anterior implica que en este caso el algorimo no es 
\series bold
óptimo
\series default
.
 A pesar de lo anterior tras ejecutar el algoritmo se ha comprobado que
 las soluciones ofrecidas por el algoritmo son prácticamente siempre las
 mejores, y en caso de no serlo, son bastante aproximadas.
\end_layout

\begin_layout Standard
Veamos ahora la evolución temporal del algoritmo en función del número de
 ciudades del problema.
 Para cada una de las ejecuciones se atenderá al número de nodos que han
 sido expandidos durante la búsqueda.
 Hay que decir que para un número de ciudades constante, al variar los valores
 de su matriz de distancias, el número de nodos expandidos variará, es decir,
 el porcentaje del árbol de búsqueda que se visita varía.
\end_layout

\begin_layout Standard
Pese a utilizar de nuevo colas de prioridad aquí la memoria no supone tanto
 problema cómo en el algorimo anterior ya que A estrella converge mucho
 más deprisa hacia una solución.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename alg04.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Nodos expandidos en función del número de ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Número de ciudades
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
37
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
422
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
808
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8528
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
223
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
232058
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
75
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14370
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5278
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Valores obtenidos en la ejecución.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Atendiendo al gráfico no se muestra el carácter 
\series bold
exponencial
\series default
 del algoritmo ya que puede ejecutarse para más de 100 ciudades.
 Cómo se dijo en clase el principal problema de este algoritmo es que suele
 quedarse sin memoria y así ocurre cuándo se ha intentado probar para más
 de 100 ciudades.
 Aún así no se debe dudar de su coste exponencial en este caso ya que el
 error de la función heurística crece más rápido que el logaritmo del costo
 real de la ruta.
\end_layout

\begin_layout Standard
Este algoritmo permite ejecutarse con un valor máximo de 
\series bold
100 ciudades
\series default
, si no se presentan problemas de memoria (tamaño de las colas de prioridad).
\end_layout

\begin_layout Section
Búsqueda del vecino más próximo
\end_layout

\begin_layout Standard
El algoritmo del Vecino más próximo fué uno de los primeros algoritmos usados
 para encontrar la solución al problema del viajante de comercio.
 Rápidamente encuentra una solución pero generalmente ésta no es la 
\series bold
óptima
\series default
.
\end_layout

\begin_layout Standard
Este algoritmo es fácil de implementar y se ejecuta rápido pero puede en
 ocasiones perder rutas más cortas.
 Cómo guía general, si las últimas etapas de la ruta son comparables en
 coste a las primeras, entonces la ruta será razonable; si son mucho más
 grandes la solución hallada será muy mejorable.
\end_layout

\begin_layout Subsubsection*

\series bold
\bar under
Características del algoritmo
\end_layout

\begin_layout Standard
Aspectos positivos:
\end_layout

\begin_layout Itemize
Es un algoritmo muy rápido.
\end_layout

\begin_layout Itemize
Su consumo de memoria muy bajo.
\end_layout

\begin_layout Standard
Aspectos negativos:
\end_layout

\begin_layout Itemize
No es óptimo.
\end_layout

\begin_layout Subsubsection*

\bar under
Evaluación del algoritmo de búsqueda
\end_layout

\begin_layout Description
Completitud: Sí.
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
temporal: O(m)
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
espacial: O(m)
\end_layout

\begin_layout Subsubsection*

\bar under
Resultados
\end_layout

\begin_layout Standard
Veamos ahora la evolución temporal del algoritmo en función del número de
 ciudades del problema.
 Para cada una de las ejecuciones se atenderá al número de nodos que han
 sido expandidos durante la búsqueda.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename alg05.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Nodos expandidos en función del número de ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Número de ciudades
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
21
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
51
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
75
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
76
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
101
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Valores obtenidos en la ejecución.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Observando el gráfico queda patente el caracter 
\series bold
lineal
\series default
 del algoritmo.
\end_layout

\begin_layout Standard
Este algoritmo prescinde de la optimalidad en la solución para lograr un
 tiempo de ejecución mínimo.
 Se recomienda usar este algoritmo cuándo no se dispone de gran poder computacio
nal y/o no se necesita encontrar la mejor solución.
\end_layout

\begin_layout Standard
En general este algoritmo no suele dar malas soluciones.
 Es muy improbable que de el peor de los casos.
 Puede ejecutarse para 
\series bold
cientos de ciudades
\series default
.
\end_layout

\begin_layout Section
Método de escalada
\end_layout

\begin_layout Standard
El algoritmo de escalada consiste en recorrer las distintos nodos explorando
 en cada momento aquel cuyo coste f(x)’, que incluye el coste real de la
 ruta g(x), y el coste de h(x)’, aproximación a h(x), sea menor.
\end_layout

\begin_layout Standard
Constituye un caso particular de una búsqueda en profundidad sin posibilidad
 de vuelta atrás.
\end_layout

\begin_layout Standard
Es parecido al algoritmo del apartado anterior, pero para el problema de
 esta práctica no tiene sentido utilizarlo, ya que no obtiene buenas rutas.
\end_layout

\begin_layout Subsubsection*

\bar under
Características del algoritmo
\end_layout

\begin_layout Standard
Aspectos positivos:
\end_layout

\begin_layout Itemize
Es un algoritmo tan rápido cómo el Vecino más Próximo.
\end_layout

\begin_layout Itemize
Tiene un bajo consumo de memoria.
\end_layout

\begin_layout Standard
Aspectos negativos:
\end_layout

\begin_layout Itemize
No es óptimo.
\end_layout

\begin_layout Itemize
Puede quedar estancado.
\end_layout

\begin_layout Subsubsection*

\bar under
Evaluación del algoritmo de búsqueda
\end_layout

\begin_layout Description
Completitud: No, es irrevocable (no puede volver atrás).
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
temporal: O(m)
\end_layout

\begin_layout Description
Complejidad\InsetSpace ~
espacial: O(m)
\end_layout

\begin_layout Subsubsection*

\bar under
Resultados
\end_layout

\begin_layout Standard
Se muestra a continuación la evolución temporal del algoritmo en función
 del número de ciudades del problema.
 Para cada una de las ejecuciones se atenderá al número de nodos que han
 sido expandidos durante la búsqueda.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename alg06.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Nodos expandidos en función del número de ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Número de ciudades
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
21
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
51
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
75
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
76
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
101
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Valores obtenidos en la ejecución.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Queda claro por lo tanto que es muy parecido al anterior algorimo siendo
 también 
\series bold
lineal.
 
\series default
Aquí es imposible evaluar lo bueno que es un estado por sí mismo (habría
 que hacerlo en relación a las demás rutas), con lo cual es mejor 
\series bold
evitar el uso
\series default
 de este algoritmo.
\end_layout

\begin_layout Section
Comparativa
\end_layout

\begin_layout Standard
Veamos ahora una serie de gráficos que dejen constancia del número de nodos
 expandidos para distinto número de ciudades aplicando los seis algoritmos
 vistos en secciones anteriores.
 Para cierto número de ciudades no todos los algoritmos podrán ser ejecutados.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename comp01.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Comparativa para 11 ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Algoritmo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Primero en Profundidad (A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13492901
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ramificación y Poda (B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16149
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Costo Uniforme (C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13595
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A Estrella (D)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
813
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vecino más Próximo (E)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
12
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Escalada (F)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Comparativa para 11 ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename comp02.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Comparativa para 14 ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Algoritmo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ramificación y Poda (B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1689825
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Costo Uniforme (C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
347424
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A Estrella (D)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
699
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vecino más Próximo (E)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
15
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Escalada (F)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
15
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Comparativa para 14 ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename comp03.JPG

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Comparativa para 100 ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Algoritmo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nodos expandidos
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A Estrella (D)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5278
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vecino más Próximo (E)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
101
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Escalada (F)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
101
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Comparativa para 100 ciudades.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*

\bar under
Conclusiones
\end_layout

\begin_layout Itemize
Para el algoritmo de Búsqueda en Profundidad el número de nodos visitados
 crece desorbitadamente en comparación con los demás algoritmos únicamente
 para 11 ciudades.
\end_layout

\begin_layout Itemize
Los algoritmos de Ramificación y Poda y Costo Uniforme permiten ejecutarse
 con unas pocas ciudades más que el algoritmo anterior, concretamente 14.
 Además pese a que el algoritmo de Costo Uniforme expande menos nodos su
 ejecución es más lenta que el de Ramificación y poda; todo se debe a que
 debe gestionar una cola de prioridad.
\end_layout

\begin_layout Itemize
A Estrella presenta el mejor comportamiento.
 Permite obtener en la mayoría de casos una solución óptima con muy pocos
 nodos recorridos.
\end_layout

\begin_layout Itemize
Los algoritmos del Vecino más Próximo y Escalada recorren un número lineal
 de nodos pero no garantizan encontrar la mejor solución, por eso son considerad
os peores que A Estrella.
\end_layout

\begin_layout Itemize
Para concluir puede afirmarse que dada una gran cantidad de ciudades, no
 debe utilizarse el algoritmo de Búsqueda en Profundidad, la 
\series bold
mejor opción será aplicar el algoritmo A Estrella
\series default
 que encontrará la mejor solución en muy poco tiempo.
 
\end_layout

\begin_layout Section
Código fuente
\end_layout

\begin_layout Standard
Esta práctica se ha implementado mediante el lenguaje Java (entorno Netbeans
 5.5).
 Para ejecutar la aplicación se adjunta un archivo con extensión jar (TravelingS
alesMan.jar) en la carpeta dist de ejecución directa en sistemas operativos
 de tipo Windows y Linux.
\end_layout

\begin_layout Standard
Consideraciones previas:
\end_layout

\begin_layout Itemize

\emph on
Rutas
\emph default
: Las distancias entre las diferentes ciudades del problema se han recogido
 en forma de matriz n*n siendo n el número de ciudades.
 Así la diagonal de la misma es cero y además el valor de la ruta de la
 ciudad
\series bold
 A
\series default
 a la 
\series bold
B 
\series default
coincide con el valor de 
\series bold
B 
\series default
a 
\series bold
A
\series default
.
 Dicha matriz aparece en la clase RoutesMatrix.
\end_layout

\begin_layout Standard
A continuación se muestran las clases en las que se divide la aplicación.
\end_layout

\begin_layout Subsection
AStar
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * AStar.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-03-30 22:35:24 +0200 (dom, 30 mar 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 15 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * Implementation of the A* (A Star) algorithm.
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import java.util.ArrayList;
\end_layout

\begin_layout Standard

import java.util.Comparator;
\end_layout

\begin_layout Standard

import java.util.PriorityQueue;
\end_layout

\begin_layout Standard

import java.util.Vector;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class AStar {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    RoutesMatrix distances;
\end_layout

\begin_layout Standard

    int sourceCity;
\end_layout

\begin_layout Standard

    PriorityQueue<Town> opened = new PriorityQueue<Town>(1000, 
\end_layout

\begin_layout Standard

        new Comparator<Town>() {
\end_layout

\begin_layout Standard

          public int compare(Town a, Town b) {
\end_layout

\begin_layout Standard

            return a.f - b.f;
\end_layout

\begin_layout Standard

          }
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

      );  
\end_layout

\begin_layout Standard

    String result = new String();
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    ArrayList optimumRoute;
\end_layout

\begin_layout Standard

    int nodes = 0;
\end_layout

\begin_layout Standard

    int optimumCost = Integer.MAX_VALUE;     
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    // Estimation of the cost between two cities, it can overestimate the
 real value (h' > h),
\end_layout

\begin_layout Standard

    // so the algorithm it's not optimum.
\end_layout

\begin_layout Standard

    int HEURISTICCONSTANT = 15;
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * Gets the heuristic value for a given depth
\end_layout

\begin_layout Standard

     * The level 0 has the maximum value.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    private int getHeuristicValue (int level) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return HEURISTICCONSTANT * (distances.getCitiesCount() - level);
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates a new instance of AStar */
\end_layout

\begin_layout Standard

    public AStar(RoutesMatrix matrix, int sourceCity) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        distances = matrix;
\end_layout

\begin_layout Standard

        this.sourceCity = sourceCity;        
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * executes the algorithm
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public String execute() {
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        // have we found the solution?
\end_layout

\begin_layout Standard

        boolean solution = false;
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // start the timer
\end_layout

\begin_layout Standard

        long startTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // initial town
\end_layout

\begin_layout Standard

        opened.add(new Town(sourceCity, 0, getHeuristicValue(0), 0));
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        while (!opened.isEmpty() && !solution) {
\end_layout

\begin_layout Standard

            // gets the city with lower g value
\end_layout

\begin_layout Standard

            Town currentTown = opened.poll();
\end_layout

\begin_layout Standard

            nodes++;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

            // rebuild the followed route for the selected town
\end_layout

\begin_layout Standard

            Town aux = currentTown;
\end_layout

\begin_layout Standard

            ArrayList followedRoute = new ArrayList();
\end_layout

\begin_layout Standard

            followedRoute.add(aux.number);
\end_layout

\begin_layout Standard

            while (aux.level != 0) {
\end_layout

\begin_layout Standard

                aux = aux.parent;
\end_layout

\begin_layout Standard

                followedRoute.add(0, aux.number);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            if (currentTown.level == distances.getCitiesCount()) {
\end_layout

\begin_layout Standard

                solution = true;
\end_layout

\begin_layout Standard

                optimumRoute = followedRoute;
\end_layout

\begin_layout Standard

                optimumCost = currentTown.g;
\end_layout

\begin_layout Standard

            } else {
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

                for (int i=0; i<distances.getCitiesCount(); i++) {
\end_layout

\begin_layout Standard

                    // have we visited this city in the current followed
 route?
\end_layout

\begin_layout Standard

                    boolean visited = followedRoute.contains(i);
\end_layout

\begin_layout Standard

                    boolean isSolution = (followedRoute.size() == distances.getCit
iesCount())&&(i == sourceCity);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                    if (!visited || isSolution) {
\end_layout

\begin_layout Standard

                        Town childTown = new Town(i, currentTown.g + distances.get
Cost(currentTown.number, i), 
\end_layout

\begin_layout Standard

                                getHeuristicValue(currentTown.level + 1),
 currentTown.level + 1);
\end_layout

\begin_layout Standard

                        childTown.parent = currentTown;
\end_layout

\begin_layout Standard

                        opened.add(childTown);  
\end_layout

\begin_layout Standard

                    }
\end_layout

\begin_layout Standard

                }                
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        long endTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        result = "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result +=  "A ESTRELLA:
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result += "MEJOR SOLUCIÓN: 
\backslash
t"+optimumRoute.toString() + "
\backslash
nCOSTE: 
\backslash
t
\backslash
t"+optimumCost+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "NODOS VISITADOS: 
\backslash
t"+nodes+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "TIEMPO TRANSCURRIDO: 
\backslash
t"+(endTime-startTime)+" ms
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return result;        
\end_layout

\begin_layout Standard

    }    
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
BranchAndBound
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * BranchAndBound.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-03-30 22:35:24 +0200 (dom, 30 mar 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 15 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * Implementation of the branch and bound search algorithm.
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import java.util.ArrayList;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class BranchAndBound {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    RoutesMatrix distances;
\end_layout

\begin_layout Standard

    int sourceCity;
\end_layout

\begin_layout Standard

    String result = new String();
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    ArrayList initialRoute, optimumRoute;
\end_layout

\begin_layout Standard

    int nodes = 0;
\end_layout

\begin_layout Standard

    int routeCost = 0;
\end_layout

\begin_layout Standard

    int optimumCost = Integer.MAX_VALUE;    
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates a new instance of BranchAndBound */
\end_layout

\begin_layout Standard

    public BranchAndBound(RoutesMatrix matrix, int sourceCity) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        distances = matrix;
\end_layout

\begin_layout Standard

        this.sourceCity = sourceCity;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * executes the algorithm
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public String execute () {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        initialRoute = new ArrayList();
\end_layout

\begin_layout Standard

        initialRoute.add(sourceCity);
\end_layout

\begin_layout Standard

        optimumRoute = new ArrayList();
\end_layout

\begin_layout Standard

        nodes++;        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        result = "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result +=  "RAMIFICACIÓN Y PODA:
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        long startTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        search(sourceCity, initialRoute);
\end_layout

\begin_layout Standard

        long endTime = System.currentTimeMillis();        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        result += "MEJOR SOLUCIÓN: 
\backslash
t"+optimumRoute.toString() + "
\backslash
nCOSTE: 
\backslash
t
\backslash
t"+optimumCost+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "NODOS VISITADOS: 
\backslash
t"+nodes+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "TIEMPO TRANSCURRIDO: 
\backslash
t"+(endTime-startTime)+" ms
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return result;         
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * @param from node where we start the search.
\end_layout

\begin_layout Standard

     * @param route followed route for arriving to node "from".
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public void search (int from, ArrayList followedRoute) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // we've found a new solution
\end_layout

\begin_layout Standard

        if (followedRoute.size() == distances.getCitiesCount()) {
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            followedRoute.add(sourceCity);
\end_layout

\begin_layout Standard

            nodes++;
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            // update the route's cost
\end_layout

\begin_layout Standard

            routeCost += distances.getCost(from, sourceCity);
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            if (routeCost < optimumCost) {
\end_layout

\begin_layout Standard

                optimumCost = routeCost;
\end_layout

\begin_layout Standard

                optimumRoute = (ArrayList)followedRoute.clone();
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            // DEBUG
\end_layout

\begin_layout Standard

            //result += followedRoute.toString() + "// COSTE: "+routeCost
 + "
\backslash
n";
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            // update the route's cost (back to the previous value)
\end_layout

\begin_layout Standard

            routeCost -= distances.getCost(from, sourceCity);
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        else {
\end_layout

\begin_layout Standard

            for (int to=0; to<distances.getCitiesCount(); to++){
\end_layout

\begin_layout Standard

                if (!followedRoute.contains(to)) {
\end_layout

\begin_layout Standard

                    
\end_layout

\begin_layout Standard

                    // update the route's cost
\end_layout

\begin_layout Standard

                    routeCost += distances.getCost(from, to);
\end_layout

\begin_layout Standard

                    
\end_layout

\begin_layout Standard

                    if (routeCost < optimumCost) { 
\end_layout

\begin_layout Standard

                        ArrayList increasedRoute = (ArrayList)followedRoute.clone
();
\end_layout

\begin_layout Standard

                        increasedRoute.add(to);
\end_layout

\begin_layout Standard

                        nodes++;
\end_layout

\begin_layout Standard

                        search(to, increasedRoute);    
\end_layout

\begin_layout Standard

                    }
\end_layout

\begin_layout Standard

                    
\end_layout

\begin_layout Standard

                    // update the route's cost (back to the previous value)
\end_layout

\begin_layout Standard

                    routeCost -= distances.getCost(from, to);
\end_layout

\begin_layout Standard

                }
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        }        
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
DepthFirstSearch
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * DepthFirstSearch.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-03-30 22:35:24 +0200 (dom, 30 mar 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 15 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * Implementation of the depth first search algorithm.
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import java.util.ArrayList;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class DepthFirstSearch {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    RoutesMatrix distances;
\end_layout

\begin_layout Standard

    int sourceCity;
\end_layout

\begin_layout Standard

    String result = new String();
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    ArrayList initialRoute, optimumRoute;
\end_layout

\begin_layout Standard

    int nodes = 0;
\end_layout

\begin_layout Standard

    int routeCost = 0;
\end_layout

\begin_layout Standard

    int optimumCost = Integer.MAX_VALUE;
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates a new instance of DepthFirstSearch */
\end_layout

\begin_layout Standard

    public DepthFirstSearch(RoutesMatrix matrix, int sourceCity) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        distances = matrix;
\end_layout

\begin_layout Standard

        this.sourceCity = sourceCity;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * executes the algorithm
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public String execute () {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        initialRoute = new ArrayList();
\end_layout

\begin_layout Standard

        initialRoute.add(sourceCity);
\end_layout

\begin_layout Standard

        optimumRoute = new ArrayList();
\end_layout

\begin_layout Standard

        nodes++;
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        result = "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result +=  "PRIMERO EN PROFUNDIDAD:
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        long startTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        search(sourceCity, initialRoute);
\end_layout

\begin_layout Standard

        long endTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        result += "MEJOR SOLUCIÓN: 
\backslash
t"+optimumRoute.toString() + "
\backslash
nCOSTE: 
\backslash
t
\backslash
t"+optimumCost+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "NODOS VISITADOS: 
\backslash
t"+nodes+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "TIEMPO TRANSCURRIDO: 
\backslash
t"+(endTime-startTime)+" ms
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return result;         
\end_layout

\begin_layout Standard

    }    
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * @param from node where we start the search.
\end_layout

\begin_layout Standard

     * @param route followed route for arriving to node "from".
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public void search (int from, ArrayList followedRoute) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // we've found a new solution
\end_layout

\begin_layout Standard

        if (followedRoute.size() == distances.getCitiesCount()) {
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            followedRoute.add(sourceCity);
\end_layout

\begin_layout Standard

            nodes++;
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            // update the route's cost
\end_layout

\begin_layout Standard

            routeCost += distances.getCost(from, sourceCity);
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            if (routeCost < optimumCost) {
\end_layout

\begin_layout Standard

                optimumCost = routeCost;
\end_layout

\begin_layout Standard

                optimumRoute = (ArrayList)followedRoute.clone();
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            // DEBUG
\end_layout

\begin_layout Standard

            //result += followedRoute.toString() + "// COSTE: "+routeCost
 + "
\backslash
n";
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            // update the route's cost (back to the previous value)
\end_layout

\begin_layout Standard

            routeCost -= distances.getCost(from, sourceCity);
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        else {
\end_layout

\begin_layout Standard

            for (int to=0; to<distances.getCitiesCount(); to++){
\end_layout

\begin_layout Standard

                if (!followedRoute.contains(to)) {
\end_layout

\begin_layout Standard

                    
\end_layout

\begin_layout Standard

                    ArrayList increasedRoute = (ArrayList)followedRoute.clone();
\end_layout

\begin_layout Standard

                    increasedRoute.add(to);
\end_layout

\begin_layout Standard

                    nodes++;
\end_layout

\begin_layout Standard

                    
\end_layout

\begin_layout Standard

                    // update the route's cost
\end_layout

\begin_layout Standard

                    routeCost += distances.getCost(from, to);
\end_layout

\begin_layout Standard

                    
\end_layout

\begin_layout Standard

                    search(to, increasedRoute);
\end_layout

\begin_layout Standard

                    
\end_layout

\begin_layout Standard

                    // update the route's cost (back to the previous value)
\end_layout

\begin_layout Standard

                    routeCost -= distances.getCost(from, to);
\end_layout

\begin_layout Standard

                }
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        }        
\end_layout

\begin_layout Standard

    }    
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
HillClimbing
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * HillClimbing.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-03-30 20:41:41 +0200 (dom, 30 mar 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 14 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * Implementation of the Hill Climbing algorithm (simple version).
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import java.util.ArrayList;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class HillClimbing {
\end_layout

\begin_layout Standard

   
\end_layout

\begin_layout Standard

    RoutesMatrix distances;
\end_layout

\begin_layout Standard

    int sourceCity;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    String result = new String();
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    ArrayList followedRoute;
\end_layout

\begin_layout Standard

    int nodes = 0;
\end_layout

\begin_layout Standard

    int routeCost = 0;     
\end_layout

\begin_layout Standard

   
\end_layout

\begin_layout Standard

    int HEURISTICCONSTANT = 15;    
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * Gets the heuristic value for a given depth
\end_layout

\begin_layout Standard

     * The level 0 has the maximum value.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    private int getHeuristicValue (int level) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return HEURISTICCONSTANT * (distances.getCitiesCount() - level);
\end_layout

\begin_layout Standard

    }    
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates a new instance of HillClimbing */
\end_layout

\begin_layout Standard

    public HillClimbing(RoutesMatrix matrix, int sourceCity) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        distances = matrix;
\end_layout

\begin_layout Standard

        this.sourceCity = sourceCity;        
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * executes the algorithm
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public String execute () {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        followedRoute = new ArrayList();
\end_layout

\begin_layout Standard

        followedRoute.add(sourceCity);
\end_layout

\begin_layout Standard

        nodes++;
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        long startTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        search(sourceCity);
\end_layout

\begin_layout Standard

        long endTime = System.currentTimeMillis();        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        result = "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result +=  "MÉTODO DE ESCALADA:
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result += "MEJOR SOLUCIÓN: 
\backslash
t"+followedRoute.toString() + "
\backslash
nCOSTE: 
\backslash
t
\backslash
t"+routeCost+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "NODOS VISITADOS: 
\backslash
t"+nodes+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "TIEMPO TRANSCURRIDO: 
\backslash
t"+(endTime-startTime)+" ms
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return result;         
\end_layout

\begin_layout Standard

    }  
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * @param from node where we start the search.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public void search (int from) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        int currentTown = from;
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        while (nodes != distances.getCitiesCount()) {
\end_layout

\begin_layout Standard

            // choose the closest town
\end_layout

\begin_layout Standard

            int lowestDistance = Integer.MAX_VALUE;
\end_layout

\begin_layout Standard

            int chosen = -1;
\end_layout

\begin_layout Standard

            for (int i=0; i < distances.getCitiesCount(); i++) {
\end_layout

\begin_layout Standard

                if (!followedRoute.contains(i)) {
\end_layout

\begin_layout Standard

                    int tempDistance = routeCost + getHeuristicValue(nodes-1);
 // f = g + h
\end_layout

\begin_layout Standard

                    if (tempDistance < lowestDistance) {
\end_layout

\begin_layout Standard

                        lowestDistance = tempDistance;
\end_layout

\begin_layout Standard

                        chosen = i;
\end_layout

\begin_layout Standard

                    }
\end_layout

\begin_layout Standard

                }
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

            routeCost += distances.getCost(currentTown, chosen);
\end_layout

\begin_layout Standard

            followedRoute.add(chosen);
\end_layout

\begin_layout Standard

            currentTown = chosen;
\end_layout

\begin_layout Standard

            nodes++;
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        // add the last town
\end_layout

\begin_layout Standard

        routeCost += distances.getCost(currentTown, sourceCity);
\end_layout

\begin_layout Standard

        followedRoute.add(sourceCity);
\end_layout

\begin_layout Standard

        nodes++;
\end_layout

\begin_layout Standard

    }         
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Main
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * Main.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-04-01 01:27:52 +0200 (mar, 01 abr 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 22 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import javax.swing.table.DefaultTableModel;
\end_layout

\begin_layout Standard

import java.awt.*;
\end_layout

\begin_layout Standard

import java.awt.event.*;
\end_layout

\begin_layout Standard

import javax.swing.*;
\end_layout

\begin_layout Standard

import javax.swing.table.*;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class Main extends javax.swing.JFrame {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    static RoutesMatrix routes;
\end_layout

\begin_layout Standard

    int sourceCity = 0;
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates new form Main */
\end_layout

\begin_layout Standard

    public Main() {
\end_layout

\begin_layout Standard

        initComponents();
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // init the routes matrix
\end_layout

\begin_layout Standard

        routes = new RoutesMatrix(4);
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // init the cities checkbox
\end_layout

\begin_layout Standard

        for (int i = 2; i <= 100; i++)
\end_layout

\begin_layout Standard

            jComboBox1.addItem(i);
\end_layout

\begin_layout Standard

        for (int i = 2; i <= 10; i++)
\end_layout

\begin_layout Standard

            jComboBox1.addItem(i*100);
\end_layout

\begin_layout Standard

        for (int i = 0; i <= 3; i++)
\end_layout

\begin_layout Standard

            jComboBox2.addItem(i);
\end_layout

\begin_layout Standard

        jComboBox1.setSelectedIndex(2);
\end_layout

\begin_layout Standard

        jComboBox2.setSelectedIndex(0);
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // configure the JTable to display de routes matrix
\end_layout

\begin_layout Standard

        routes.drawJTable(jTable1);
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** This method is called from within the constructor to
\end_layout

\begin_layout Standard

     * initialize the form.
\end_layout

\begin_layout Standard

     * WARNING: Do NOT modify this code.
 The content of this method is
\end_layout

\begin_layout Standard

     * always regenerated by the Form Editor.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN
:initComponents
\end_layout

\begin_layout Standard

    private void initComponents() {
\end_layout

\begin_layout Standard

        jPanel1 = new javax.swing.JPanel();
\end_layout

\begin_layout Standard

        jScrollPane2 = new javax.swing.JScrollPane();
\end_layout

\begin_layout Standard

        jTable1 = new javax.swing.JTable();
\end_layout

\begin_layout Standard

        jButton6 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

        jButton7 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

        jComboBox1 = new javax.swing.JComboBox();
\end_layout

\begin_layout Standard

        jLabel1 = new javax.swing.JLabel();
\end_layout

\begin_layout Standard

        jLabel2 = new javax.swing.JLabel();
\end_layout

\begin_layout Standard

        jComboBox2 = new javax.swing.JComboBox();
\end_layout

\begin_layout Standard

        jPanel2 = new javax.swing.JPanel();
\end_layout

\begin_layout Standard

        jButton1 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

        jButton2 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

        jButton3 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

        jPanel3 = new javax.swing.JPanel();
\end_layout

\begin_layout Standard

        jButton4 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

        jButton5 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

        jButton8 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

        jPanel4 = new javax.swing.JPanel();
\end_layout

\begin_layout Standard

        jScrollPane1 = new javax.swing.JScrollPane();
\end_layout

\begin_layout Standard

        jTextArea1 = new javax.swing.JTextArea();
\end_layout

\begin_layout Standard

        jPanel5 = new javax.swing.JPanel();
\end_layout

\begin_layout Standard

        jButton9 = new javax.swing.JButton();
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
\end_layout

\begin_layout Standard

        setTitle("IA - El Viajante de Comercio (Vicente J.
 Ferrer Dalmau)");
\end_layout

\begin_layout Standard

        setBackground(new java.awt.Color(255, 255, 255));
\end_layout

\begin_layout Standard

        setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
\end_layout

\begin_layout Standard

        setResizable(false);
\end_layout

\begin_layout Standard

        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Configurar
 Ciudades"));
\end_layout

\begin_layout Standard

        jScrollPane2.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HO
RIZONTAL_SCROLLBAR_ALWAYS);
\end_layout

\begin_layout Standard

        jScrollPane2.setAutoscrolls(true);
\end_layout

\begin_layout Standard

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
\end_layout

\begin_layout Standard

            new Object [][] {
\end_layout

\begin_layout Standard

                {null, null, null, null},
\end_layout

\begin_layout Standard

                {null, null, null, null},
\end_layout

\begin_layout Standard

                {null, null, null, null},
\end_layout

\begin_layout Standard

                {null, null, null, null}
\end_layout

\begin_layout Standard

            },
\end_layout

\begin_layout Standard

            new String [] {
\end_layout

\begin_layout Standard

                "Title 1", "Title 2", "Title 3", "Title 4"
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        ));
\end_layout

\begin_layout Standard

        jTable1.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
\end_layout

\begin_layout Standard

        jScrollPane2.setViewportView(jTable1);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel1.add(jScrollPane2, new org.netbeans.lib.awtextra.AbsoluteConstraints(1
0, 20, 870, 200));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jButton6.setText("Regenerar Matriz");
\end_layout

\begin_layout Standard

        jButton6.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton6MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel1.add(jButton6, new org.netbeans.lib.awtextra.AbsoluteConstraints(590,
 230, -1, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jButton7.setText("Modificar distancias");
\end_layout

\begin_layout Standard

        jButton7.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton7MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel1.add(jButton7, new org.netbeans.lib.awtextra.AbsoluteConstraints(730,
 230, 150, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jComboBox1.addItemListener(new java.awt.event.ItemListener() {
\end_layout

\begin_layout Standard

            public void itemStateChanged(java.awt.event.ItemEvent evt) {
\end_layout

\begin_layout Standard

                jComboBox1ItemStateChanged(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel1.add(jComboBox1, new org.netbeans.lib.awtextra.AbsoluteConstraints(90,
 230, -1, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jLabel1.setText("N
\backslash
u00ba Ciudades:");
\end_layout

\begin_layout Standard

        jPanel1.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10,
 230, -1, 20));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jLabel2.setText("Ciudad inicial:");
\end_layout

\begin_layout Standard

        jPanel1.add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(160,
 230, 80, 20));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jComboBox2.addItemListener(new java.awt.event.ItemListener() {
\end_layout

\begin_layout Standard

            public void itemStateChanged(java.awt.event.ItemEvent evt) {
\end_layout

\begin_layout Standard

                jComboBox2ItemStateChanged(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel1.add(jComboBox2, new org.netbeans.lib.awtextra.AbsoluteConstraints(250
, 230, -1, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        getContentPane().add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstrain
ts(0, 0, 890, 270));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel2.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("B
\backslash
u00fasqueda No Informada"));
\end_layout

\begin_layout Standard

        jButton1.setText("Primero en profundidad");
\end_layout

\begin_layout Standard

        jButton1.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton1MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel2.add(jButton1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10,
 20, 170, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jButton2.setText("Ramificaci
\backslash
u00f3n y poda");
\end_layout

\begin_layout Standard

        jButton2.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton2MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel2.add(jButton2, new org.netbeans.lib.awtextra.AbsoluteConstraints(190,
 20, 150, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jButton3.setText("Costo uniforme");
\end_layout

\begin_layout Standard

        jButton3.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton3MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel2.add(jButton3, new org.netbeans.lib.awtextra.AbsoluteConstraints(350,
 20, 140, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        getContentPane().add(jPanel2, new org.netbeans.lib.awtextra.AbsoluteConstrain
ts(0, 480, 500, 60));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel3.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder("B
\backslash
u00fasqueda Informada"));
\end_layout

\begin_layout Standard

        jButton4.setText("Vecino m
\backslash
u00e1s pr
\backslash
u00f3ximo");
\end_layout

\begin_layout Standard

        jButton4.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton4MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel3.add(jButton4, new org.netbeans.lib.awtextra.AbsoluteConstraints(100,
 20, 170, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jButton5.setText("A*");
\end_layout

\begin_layout Standard

        jButton5.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton5MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel3.add(jButton5, new org.netbeans.lib.awtextra.AbsoluteConstraints(10,
 20, 80, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jButton8.setText("Escalada");
\end_layout

\begin_layout Standard

        jButton8.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton8MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel3.add(jButton8, new org.netbeans.lib.awtextra.AbsoluteConstraints(280,
 20, 100, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        getContentPane().add(jPanel3, new org.netbeans.lib.awtextra.AbsoluteConstrain
ts(500, 480, 390, 60));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel4.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder("Resultados")
);
\end_layout

\begin_layout Standard

        jTextArea1.setColumns(20);
\end_layout

\begin_layout Standard

        jTextArea1.setEditable(false);
\end_layout

\begin_layout Standard

        jTextArea1.setRows(5);
\end_layout

\begin_layout Standard

        jScrollPane1.setViewportView(jTextArea1);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel4.add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(1
0, 20, 870, 180));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        getContentPane().add(jPanel4, new org.netbeans.lib.awtextra.AbsoluteConstrain
ts(0, 270, 890, 210));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel5.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder("B
\backslash
u00fasqueda No Informada & Informada"));
\end_layout

\begin_layout Standard

        jButton9.setText("Todo");
\end_layout

\begin_layout Standard

        jButton9.addMouseListener(new java.awt.event.MouseAdapter() {
\end_layout

\begin_layout Standard

            public void mouseClicked(java.awt.event.MouseEvent evt) {
\end_layout

\begin_layout Standard

                jButton9MouseClicked(evt);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        jPanel5.add(jButton9, new org.netbeans.lib.awtextra.AbsoluteConstraints(400,
 20, 100, -1));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        getContentPane().add(jPanel5, new org.netbeans.lib.awtextra.AbsoluteConstrain
ts(0, 540, 890, 60));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        pack();
\end_layout

\begin_layout Standard

    }// </editor-fold>//GEN-END:initComponents
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton9MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton9MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        try {
\end_layout

\begin_layout Standard

            DepthFirstSearch s1 = new DepthFirstSearch(routes, sourceCity);
\end_layout

\begin_layout Standard

            jTextArea1.setText(s1.execute());
\end_layout

\begin_layout Standard

            BranchAndBound s2 = new BranchAndBound(routes, sourceCity);
\end_layout

\begin_layout Standard

            jTextArea1.setText(jTextArea1.getText() + s2.execute());
\end_layout

\begin_layout Standard

            UniformCost s3 = new UniformCost(routes, sourceCity);
\end_layout

\begin_layout Standard

            jTextArea1.setText(jTextArea1.getText() + s3.execute());
\end_layout

\begin_layout Standard

            AStar s6 = new AStar(routes, sourceCity);        
\end_layout

\begin_layout Standard

            jTextArea1.setText(jTextArea1.getText() + s6.execute());      
          
\end_layout

\begin_layout Standard

            NearestNeighbour s4 = new NearestNeighbour(routes, sourceCity);
\end_layout

\begin_layout Standard

            jTextArea1.setText(jTextArea1.getText() + s4.execute());
\end_layout

\begin_layout Standard

            HillClimbing s5 = new HillClimbing(routes, sourceCity);
\end_layout

\begin_layout Standard

            jTextArea1.setText(jTextArea1.getText() + s5.execute());
\end_layout

\begin_layout Standard

        } catch (java.lang.OutOfMemoryError e) {
\end_layout

\begin_layout Standard

                String msg = "La memoria no es suficiente para ejecutar
 alguno de los métodos con las "+
\end_layout

\begin_layout Standard

                        ((Integer)jComboBox1.getSelectedItem()).intValue()+"
 ciudades generadas.";
\end_layout

\begin_layout Standard

                JOptionPane.showMessageDialog(new JFrame(), msg, "Error",
 JOptionPane.ERROR_MESSAGE);
\end_layout

\begin_layout Standard

        }            
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton9MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jComboBox1ItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FI
RST:event_jComboBox1ItemStateChanged
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        if (evt.getStateChange() == evt.SELECTED) {
\end_layout

\begin_layout Standard

            // new number of cities
\end_layout

\begin_layout Standard

            int cities = ((Integer)jComboBox1.getSelectedItem()).intValue();
\end_layout

\begin_layout Standard

            routes = new RoutesMatrix(cities);
\end_layout

\begin_layout Standard

            routes.drawJTable(jTable1);
\end_layout

\begin_layout Standard

            // alter the 2nd comboBox (source city)
\end_layout

\begin_layout Standard

            jComboBox2.removeAllItems();
\end_layout

\begin_layout Standard

            for (int i=0; i<cities; i++)
\end_layout

\begin_layout Standard

                jComboBox2.addItem(i);
\end_layout

\begin_layout Standard

            jComboBox2.setSelectedIndex(0);
\end_layout

\begin_layout Standard

        }        
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jComboBox1ItemStateChanged
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jComboBox2ItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FI
RST:event_jComboBox2ItemStateChanged
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        if (evt.getStateChange() == evt.SELECTED) {
\end_layout

\begin_layout Standard

            // select the new source city
\end_layout

\begin_layout Standard

            sourceCity = ((Integer)jComboBox2.getSelectedItem()).intValue();
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jComboBox2ItemStateChanged
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton8MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton8MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        try {
\end_layout

\begin_layout Standard

        HillClimbing s = new HillClimbing(routes, sourceCity);
\end_layout

\begin_layout Standard

        jTextArea1.setText(s.execute());
\end_layout

\begin_layout Standard

        } catch (java.lang.OutOfMemoryError e) {
\end_layout

\begin_layout Standard

                String msg = "La memoria no es suficiente para ejecutar
 el Método de Escalada con las "+
\end_layout

\begin_layout Standard

                        ((Integer)jComboBox1.getSelectedItem()).intValue()+"
 ciudades generadas.";
\end_layout

\begin_layout Standard

                JOptionPane.showMessageDialog(new JFrame(), msg, "Error",
 JOptionPane.ERROR_MESSAGE);
\end_layout

\begin_layout Standard

        }        
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton8MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton4MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton4MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        try {
\end_layout

\begin_layout Standard

        NearestNeighbour s = new NearestNeighbour(routes, sourceCity);
\end_layout

\begin_layout Standard

        jTextArea1.setText(s.execute());
\end_layout

\begin_layout Standard

        } catch (java.lang.OutOfMemoryError e) {
\end_layout

\begin_layout Standard

                String msg = "La memoria no es suficiente para ejecutar
 la búsqueda del Vecino más Proximo con las "+
\end_layout

\begin_layout Standard

                        ((Integer)jComboBox1.getSelectedItem()).intValue()+"
 ciudades generadas.";
\end_layout

\begin_layout Standard

                JOptionPane.showMessageDialog(new JFrame(), msg, "Error",
 JOptionPane.ERROR_MESSAGE);
\end_layout

\begin_layout Standard

        }        
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton4MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton5MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton5MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        try {
\end_layout

\begin_layout Standard

        AStar s = new AStar(routes, sourceCity);
\end_layout

\begin_layout Standard

        jTextArea1.setText(s.execute());        
\end_layout

\begin_layout Standard

        } catch (java.lang.OutOfMemoryError e) {
\end_layout

\begin_layout Standard

                String msg = "La memoria no es suficiente para ejecutar
 la búsqueda A Estrella con las "+
\end_layout

\begin_layout Standard

                        ((Integer)jComboBox1.getSelectedItem()).intValue()+"
 ciudades generadas.";
\end_layout

\begin_layout Standard

                JOptionPane.showMessageDialog(new JFrame(), msg, "Error",
 JOptionPane.ERROR_MESSAGE);
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton5MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton3MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton3MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        try {
\end_layout

\begin_layout Standard

        UniformCost s = new UniformCost(routes, sourceCity);
\end_layout

\begin_layout Standard

        jTextArea1.setText(s.execute());
\end_layout

\begin_layout Standard

        } catch (java.lang.OutOfMemoryError e) {
\end_layout

\begin_layout Standard

                String msg = "La memoria no es suficiente para ejecutar
 la búsqueda de Costo Uniforme con las "+
\end_layout

\begin_layout Standard

                        ((Integer)jComboBox1.getSelectedItem()).intValue()+"
 ciudades generadas.";
\end_layout

\begin_layout Standard

                JOptionPane.showMessageDialog(new JFrame(), msg, "Error",
 JOptionPane.ERROR_MESSAGE);
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton3MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton2MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton2MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        try {
\end_layout

\begin_layout Standard

        BranchAndBound s = new BranchAndBound(routes, sourceCity);
\end_layout

\begin_layout Standard

        jTextArea1.setText(s.execute());
\end_layout

\begin_layout Standard

        } catch (java.lang.OutOfMemoryError e) {
\end_layout

\begin_layout Standard

                String msg = "La memoria no es suficiente para ejecutar
 la búsqueda con Ramificación y Poda con las "+
\end_layout

\begin_layout Standard

                        ((Integer)jComboBox1.getSelectedItem()).intValue()+"
 ciudades generadas.";
\end_layout

\begin_layout Standard

                JOptionPane.showMessageDialog(new JFrame(), msg, "Error",
 JOptionPane.ERROR_MESSAGE);
\end_layout

\begin_layout Standard

        }        
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton2MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton7MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton7MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        // configure the JTable to display de routes matrix
\end_layout

\begin_layout Standard

        for (int i=0; i<routes.getCitiesCount(); i++) {
\end_layout

\begin_layout Standard

            for (int j=0; j<routes.getCitiesCount(); j++) {
\end_layout

\begin_layout Standard

                int value = Integer.parseInt(jTable1.getValueAt(i, j+1).toString())
;
\end_layout

\begin_layout Standard

                if (value >= 0 && value <=routes.getMaxDistance()) {
\end_layout

\begin_layout Standard

                    routes.setCost(i, j, value);
\end_layout

\begin_layout Standard

                }
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // regenerate the jTable
\end_layout

\begin_layout Standard

        routes.drawJTable(jTable1);
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton7MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton6MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton6MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        int cities = ((Integer)jComboBox1.getItemAt(jComboBox1.getSelectedIndex())
).intValue();
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

        routes = new RoutesMatrix(cities);
\end_layout

\begin_layout Standard

        routes.drawJTable(jTable1);
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton6MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    private void jButton1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:e
vent_jButton1MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        try {
\end_layout

\begin_layout Standard

        DepthFirstSearch s = new DepthFirstSearch(routes, sourceCity);
\end_layout

\begin_layout Standard

        jTextArea1.setText(s.execute());
\end_layout

\begin_layout Standard

        } catch (java.lang.OutOfMemoryError e) {
\end_layout

\begin_layout Standard

                String msg = "La memoria no es suficiente para ejecutar
 la búsqueda Primero en Profundidad con las "+
\end_layout

\begin_layout Standard

                        ((Integer)jComboBox1.getSelectedItem()).intValue()+"
 ciudades generadas.";
\end_layout

\begin_layout Standard

                JOptionPane.showMessageDialog(new JFrame(), msg, "Error",
 JOptionPane.ERROR_MESSAGE);
\end_layout

\begin_layout Standard

        }        
\end_layout

\begin_layout Standard

    }//GEN-LAST:event_jButton1MouseClicked
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    public void printResults(String results) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        jTextArea1.setText(results);
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * @param args the command line arguments
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public static void main(String args[]) {
\end_layout

\begin_layout Standard

        java.awt.EventQueue.invokeLater(new Runnable() {
\end_layout

\begin_layout Standard

            public void run() {
\end_layout

\begin_layout Standard

                new Main().setVisible(true);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        });
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    // Variables declaration - do not modify//GEN-BEGIN:variables
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton1;
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton2;
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton3;
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton4;
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton5;
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton6;
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton7;
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton8;
\end_layout

\begin_layout Standard

    private javax.swing.JButton jButton9;
\end_layout

\begin_layout Standard

    private javax.swing.JComboBox jComboBox1;
\end_layout

\begin_layout Standard

    private javax.swing.JComboBox jComboBox2;
\end_layout

\begin_layout Standard

    private javax.swing.JLabel jLabel1;
\end_layout

\begin_layout Standard

    private javax.swing.JLabel jLabel2;
\end_layout

\begin_layout Standard

    private javax.swing.JPanel jPanel1;
\end_layout

\begin_layout Standard

    private javax.swing.JPanel jPanel2;
\end_layout

\begin_layout Standard

    private javax.swing.JPanel jPanel3;
\end_layout

\begin_layout Standard

    private javax.swing.JPanel jPanel4;
\end_layout

\begin_layout Standard

    private javax.swing.JPanel jPanel5;
\end_layout

\begin_layout Standard

    private javax.swing.JScrollPane jScrollPane1;
\end_layout

\begin_layout Standard

    private javax.swing.JScrollPane jScrollPane2;
\end_layout

\begin_layout Standard

    private javax.swing.JTable jTable1;
\end_layout

\begin_layout Standard

    private javax.swing.JTextArea jTextArea1;
\end_layout

\begin_layout Standard

    // End of variables declaration//GEN-END:variables
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
NearestNeighbour
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * NearestNeighbour.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-03-30 20:41:41 +0200 (dom, 30 mar 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 14 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * Implementation of the Nearest Neighbour algorithm.
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import java.util.ArrayList;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class NearestNeighbour {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    RoutesMatrix distances;
\end_layout

\begin_layout Standard

    int sourceCity;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    String result = new String();
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    ArrayList followedRoute;
\end_layout

\begin_layout Standard

    int nodes = 0;
\end_layout

\begin_layout Standard

    int routeCost = 0;   
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates a new instance of NearestNeighbour */
\end_layout

\begin_layout Standard

    public NearestNeighbour(RoutesMatrix matrix, int sourceCity) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        distances = matrix;
\end_layout

\begin_layout Standard

        this.sourceCity = sourceCity;        
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * executes the algorithm
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public String execute () {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        followedRoute = new ArrayList();
\end_layout

\begin_layout Standard

        followedRoute.add(sourceCity);
\end_layout

\begin_layout Standard

        nodes++;        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        long startTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        search(sourceCity);
\end_layout

\begin_layout Standard

        long endTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        result = "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result +=  "VECINO MÁS PRÓXIMO:
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result += "MEJOR SOLUCIÓN: 
\backslash
t"+followedRoute.toString() + "
\backslash
nCOSTE: 
\backslash
t
\backslash
t"+routeCost+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "NODOS VISITADOS: 
\backslash
t"+nodes+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "TIEMPO TRANSCURRIDO: 
\backslash
t"+(endTime-startTime)+" ms
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return result;         
\end_layout

\begin_layout Standard

    }   
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * @param from node where we start the search.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public void search (int from) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        int currentTown = from;
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        while (nodes != distances.getCitiesCount()) {
\end_layout

\begin_layout Standard

            // choose the closest town
\end_layout

\begin_layout Standard

            int lowestDistance = Integer.MAX_VALUE;
\end_layout

\begin_layout Standard

            int chosen = -1;
\end_layout

\begin_layout Standard

            for (int i=0; i < distances.getCitiesCount(); i++) {
\end_layout

\begin_layout Standard

                if (!followedRoute.contains(i)) {
\end_layout

\begin_layout Standard

                    int tempDistance = distances.getCost(currentTown, i);
\end_layout

\begin_layout Standard

                    if (tempDistance < lowestDistance) {
\end_layout

\begin_layout Standard

                        lowestDistance = tempDistance;
\end_layout

\begin_layout Standard

                        chosen = i;
\end_layout

\begin_layout Standard

                    }
\end_layout

\begin_layout Standard

                }
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

            routeCost += distances.getCost(currentTown, chosen);
\end_layout

\begin_layout Standard

            followedRoute.add(chosen);
\end_layout

\begin_layout Standard

            currentTown = chosen;
\end_layout

\begin_layout Standard

            nodes++;
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        // add the last town
\end_layout

\begin_layout Standard

        routeCost += distances.getCost(currentTown, sourceCity);
\end_layout

\begin_layout Standard

        followedRoute.add(sourceCity);
\end_layout

\begin_layout Standard

        nodes++;
\end_layout

\begin_layout Standard

    }    
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
RoutesMatrix
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * RoutesMatrix.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-03-30 22:35:24 +0200 (dom, 30 mar 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 15 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * This class defines all the distances between the cities in the problem.
\end_layout

\begin_layout Standard

 * For two cities, x and y, the both distances x to y and y to x remain
 the same.
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import java.awt.Color;
\end_layout

\begin_layout Standard

import java.awt.Component;
\end_layout

\begin_layout Standard

import java.util.Random;
\end_layout

\begin_layout Standard

import javax.swing.JTable;
\end_layout

\begin_layout Standard

import javax.swing.JTextField;
\end_layout

\begin_layout Standard

import javax.swing.table.DefaultTableCellRenderer;
\end_layout

\begin_layout Standard

import javax.swing.table.DefaultTableModel;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class RoutesMatrix {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    private int[][] theMatrix;
\end_layout

\begin_layout Standard

    private int cities;
\end_layout

\begin_layout Standard

    // all the distance values will be in a Uniform(MAXDISTANCE)
\end_layout

\begin_layout Standard

    private int MAXDISTANCE = 100;
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates a new instance of RoutesMatrix
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public RoutesMatrix(int cities) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        theMatrix = new int[cities][cities];
\end_layout

\begin_layout Standard

        this.cities = cities;
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // fill the matrix with random values
\end_layout

\begin_layout Standard

        // a new random generator (seed based on the current time)
\end_layout

\begin_layout Standard

        Random generator = new Random();
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        for (int i=0; i<cities; i++) {
\end_layout

\begin_layout Standard

            for (int j=i; j<cities; j++) {
\end_layout

\begin_layout Standard

                if (i == j)
\end_layout

\begin_layout Standard

                    theMatrix[i][j] = 0;
\end_layout

\begin_layout Standard

                else {
\end_layout

\begin_layout Standard

                    theMatrix[i][j] = generator.nextInt(MAXDISTANCE);
\end_layout

\begin_layout Standard

                    theMatrix[j][i] = theMatrix[i][j];
\end_layout

\begin_layout Standard

                }
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

   
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * returns the number of cities
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public int getCitiesCount() {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return cities;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * gets the cost of going from city "a" to city "b"
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public int getCost(int a, int b) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return theMatrix[a][b];
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * sets the cost of going from city "a" to city "b"
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public void setCost(int a, int b, int cost) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        theMatrix[a][b] = cost;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * gets the array of costs as an Object[][] array.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public Object[][] getCosts () {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        Object [][] array = new Object[cities][cities+1];
\end_layout

\begin_layout Standard

        for (int i=0; i<cities; i++){
\end_layout

\begin_layout Standard

            for (int j=0; j<cities; j++){
\end_layout

\begin_layout Standard

                if (j == 0) {
\end_layout

\begin_layout Standard

                    array[i][0] = i;
\end_layout

\begin_layout Standard

                    array[i][j+1] = theMatrix[i][j];
\end_layout

\begin_layout Standard

                }
\end_layout

\begin_layout Standard

                else
\end_layout

\begin_layout Standard

                    array[i][j+1] = theMatrix[i][j];
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        return array;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * gets the cities in an Object[] array.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public Object[] getCities () {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        Object[] array = new Object[cities+1];
\end_layout

\begin_layout Standard

        for (int i=0; i<cities; i++) {
\end_layout

\begin_layout Standard

            if (i == 0) {
\end_layout

\begin_layout Standard

                array[i] = " ";
\end_layout

\begin_layout Standard

                array[i+1] = 0;
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

            else
\end_layout

\begin_layout Standard

                array[i+1] = i;
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        return array;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * gets the maximum distance between two cities.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public int getMaxDistance() {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return MAXDISTANCE;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    public String toString() {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        String str = new String();
\end_layout

\begin_layout Standard

        for (int i=0; i<cities; i++) {
\end_layout

\begin_layout Standard

            for (int j=0; j<cities; j++) {
\end_layout

\begin_layout Standard

                if (j == cities - 1)
\end_layout

\begin_layout Standard

                    str += theMatrix[i][j] + "
\backslash
n";
\end_layout

\begin_layout Standard

                else
\end_layout

\begin_layout Standard

                    str += theMatrix[i][j] + ", ";
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        return str;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    // Redefine the behaviour of the table
\end_layout

\begin_layout Standard

    public class MyRender extends DefaultTableCellRenderer {
\end_layout

\begin_layout Standard

       public Component getTableCellRendererComponent(JTable table,
\end_layout

\begin_layout Standard

          Object value,
\end_layout

\begin_layout Standard

          boolean isSelected,
\end_layout

\begin_layout Standard

          boolean hasFocus,
\end_layout

\begin_layout Standard

          int row,
\end_layout

\begin_layout Standard

          int column)
\end_layout

\begin_layout Standard

       {
\end_layout

\begin_layout Standard

          super.getTableCellRendererComponent (table, value, isSelected,
 hasFocus, row, column);
\end_layout

\begin_layout Standard

          this.setOpaque(true);
\end_layout

\begin_layout Standard

          this.setToolTipText("");
\end_layout

\begin_layout Standard

          if (column == 0) {
\end_layout

\begin_layout Standard

                this.setBackground(Color.LIGHT_GRAY);
\end_layout

\begin_layout Standard

                this.setHorizontalAlignment(JTextField.CENTER);
\end_layout

\begin_layout Standard

          }
\end_layout

\begin_layout Standard

          else if (column -1 == row) {
\end_layout

\begin_layout Standard

                this.setBackground(Color.LIGHT_GRAY);
\end_layout

\begin_layout Standard

          }
\end_layout

\begin_layout Standard

          else {
\end_layout

\begin_layout Standard

                this.setBackground(Color.WHITE);
\end_layout

\begin_layout Standard

                this.setToolTipText("De la ciudad "+row+" a la "+(column-1));
\end_layout

\begin_layout Standard

          }
\end_layout

\begin_layout Standard

          return this;
\end_layout

\begin_layout Standard

       }
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** 
\end_layout

\begin_layout Standard

     * Shows the content of the matrix in a JTable object.
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public void drawJTable (JTable j) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        DefaultTableModel dtm = new DefaultTableModel() {
\end_layout

\begin_layout Standard

            public boolean isCellEditable(int row, int column) {
\end_layout

\begin_layout Standard

                if (column != 0 && (column - 1 != row))
\end_layout

\begin_layout Standard

                    return true;
\end_layout

\begin_layout Standard

                else
\end_layout

\begin_layout Standard

                    return false;
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        };
\end_layout

\begin_layout Standard

        dtm.setDataVector(this.getCosts(), this.getCities());
\end_layout

\begin_layout Standard

        // set the background of the first column
\end_layout

\begin_layout Standard

        j.setModel(dtm);
\end_layout

\begin_layout Standard

        j.setDefaultRenderer (Object.class, new MyRender());
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Town
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * Town.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-03-28 21:37:21 +0100 (vie, 28 mar 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 9 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * Contains all the important information about a Town.
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class Town {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    public int number;
\end_layout

\begin_layout Standard

    public int f, g, h;
\end_layout

\begin_layout Standard

    public int level;
\end_layout

\begin_layout Standard

    public Town parent = null;
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates a new instance of Town */
\end_layout

\begin_layout Standard

    public Town(int number, int g, int h, int level) {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

        this.number = number;
\end_layout

\begin_layout Standard

        this.g = g;
\end_layout

\begin_layout Standard

        this.h = h;
\end_layout

\begin_layout Standard

        this.f = this.g + this.h;
\end_layout

\begin_layout Standard

        this.level = level;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
UniformCost
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Java,numbers=left"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * UniformCost.java
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * $LastChangedDate: 2008-03-30 20:41:41 +0200 (dom, 30 mar 2008) $
\end_layout

\begin_layout Standard

 * $LastChangedRevision: 14 $
\end_layout

\begin_layout Standard

 * Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 * < vicente@jdalmau.es >
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * Implementation of the Uniform Cost algorithm.
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

package travelingsalesman;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import java.util.ArrayList;
\end_layout

\begin_layout Standard

import java.util.Comparator;
\end_layout

\begin_layout Standard

import java.util.PriorityQueue;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/**
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * @author Vicente J.
 Ferrer Dalmau
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

public class UniformCost {
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    RoutesMatrix distances;
\end_layout

\begin_layout Standard

    int sourceCity;
\end_layout

\begin_layout Standard

    PriorityQueue<Town> toExpand = new PriorityQueue<Town>(200, 
\end_layout

\begin_layout Standard

        new Comparator<Town>() {
\end_layout

\begin_layout Standard

          public int compare(Town a, Town b) {
\end_layout

\begin_layout Standard

            return a.g - b.g;
\end_layout

\begin_layout Standard

          }
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

      );  
\end_layout

\begin_layout Standard

    String result = new String();
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    ArrayList optimumRoute, followedRoute;
\end_layout

\begin_layout Standard

    int nodes = 0;
\end_layout

\begin_layout Standard

    int routeCost = 0;
\end_layout

\begin_layout Standard

    int optimumCost = Integer.MAX_VALUE;      
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /** Creates a new instance of UniformCost */
\end_layout

\begin_layout Standard

    public UniformCost(RoutesMatrix matrix, int sourceCity) {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        distances = matrix;
\end_layout

\begin_layout Standard

        this.sourceCity = sourceCity;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

    /**
\end_layout

\begin_layout Standard

     * executes the algorithm
\end_layout

\begin_layout Standard

     */
\end_layout

\begin_layout Standard

    public String execute() {
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // have we found the solution?
\end_layout

\begin_layout Standard

        boolean solution = false;
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // start the timer
\end_layout

\begin_layout Standard

        long startTime = System.currentTimeMillis();
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        // initial town
\end_layout

\begin_layout Standard

        toExpand.add(new Town(sourceCity, 0, 0, 0));
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        while (!toExpand.isEmpty() && !solution) {
\end_layout

\begin_layout Standard

            // gets the city with lower g value
\end_layout

\begin_layout Standard

            Town currentTown = toExpand.poll();
\end_layout

\begin_layout Standard

            nodes++;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

            // rebuild the followed route for the selected town
\end_layout

\begin_layout Standard

            Town aux = currentTown;
\end_layout

\begin_layout Standard

            followedRoute = new ArrayList();
\end_layout

\begin_layout Standard

            followedRoute.add(aux.number);
\end_layout

\begin_layout Standard

            while (aux.level != 0) {
\end_layout

\begin_layout Standard

                aux = aux.parent;
\end_layout

\begin_layout Standard

                followedRoute.add(0, aux.number);
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

            
\end_layout

\begin_layout Standard

            if (currentTown.level == distances.getCitiesCount()) {
\end_layout

\begin_layout Standard

                solution = true;
\end_layout

\begin_layout Standard

                optimumRoute = followedRoute;
\end_layout

\begin_layout Standard

                optimumCost = currentTown.g;
\end_layout

\begin_layout Standard

            } else {
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

                for (int i=0; i<distances.getCitiesCount(); i++) {
\end_layout

\begin_layout Standard

                    // have we visited this city in the current followed
 route?
\end_layout

\begin_layout Standard

                    boolean visited = followedRoute.contains(i);
\end_layout

\begin_layout Standard

                    boolean isSolution = (followedRoute.size() == distances.getCit
iesCount())&&(i == sourceCity);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                    if (!visited || isSolution) {
\end_layout

\begin_layout Standard

                        Town childTown = new Town(i, currentTown.g + distances.get
Cost(currentTown.number, i), 0, currentTown.level + 1);
\end_layout

\begin_layout Standard

                        childTown.parent = currentTown;
\end_layout

\begin_layout Standard

                        toExpand.add(childTown);  
\end_layout

\begin_layout Standard

                    }
\end_layout

\begin_layout Standard

                }                
\end_layout

\begin_layout Standard

            }
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

        long endTime = System.currentTimeMillis();        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        result = "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result +=  "BÚSQUEDA DE COSTO UNIFORME:
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";
\end_layout

\begin_layout Standard

        result += "MEJOR SOLUCIÓN: 
\backslash
t"+optimumRoute.toString() + "
\backslash
nCOSTE: 
\backslash
t
\backslash
t"+optimumCost+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "NODOS VISITADOS: 
\backslash
t"+nodes+"
\backslash
n";
\end_layout

\begin_layout Standard

        result += "TIEMPO TRANSCURRIDO: 
\backslash
t"+(endTime-startTime)+" ms
\backslash
n";
\end_layout

\begin_layout Standard

        result += "-------------------------------------
\backslash
n";        
\end_layout

\begin_layout Standard

        
\end_layout

\begin_layout Standard

        return result;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\end_body
\end_document
